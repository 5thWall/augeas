Attempt at defining a grammar to drive scanning of config files.

Reversing
---------

  Easy for parsed text, just travel the parse tree

  For new nodes, need to construct parse tree
    - given a node and a set of rules, find corresponding rule
    - for each rule mentioned on the RHS, do the same
    - generate tokens for those rules and insert into token stream
    - reverse by linking tokens to their values in tree

  Example:
    new nodes
      hosts/i1/ipaddr
      hosts/i1/canonical
      hosts/i1/aliases
      
      r = rule(hosts) ; known
      
Grammar for rules
-----------------

  see format.y

Data structures
---------------

  see format.h

Parsing
-------

  Use LL(1) ? Something else ?

Tokenize
--------

- turn every quoted

Actions
-------

node statement: appends something to path.
  Effective from earliest possible place in the rule to end of rule
  earliest possible: start of rule (constants) or right after token
    has been read

Reverse algorithm:
  Input: node

reverse(r, n) {
  if r.type == 'match'
    reverse_match(r, n)
  elsif r.type == 'match_seq'
    reverse_match_seq(r, n)
  elsif r.type == 'match_prim'
    reverse_match_prim(r, n)
}

reverse_match(r, n) {
  if r.quant == '*' || r.quant == '+' || 
     r.quant == '?' && only_child?(n.parent, n) {
    reverse_match_seq(r.match_seq, n)
  } else {
    error
  }
}

reverse_match_seq(r, n) {
  for s in r.match_prims {
    
  }
}


Reverse actions:
  - emit value
  - emit key/value
  - emit sep
  - tree nav

Reverse table:

  file: ( comment | section ) * == ( comment * | section * ) *
    -> 
    <- for c in n.children
         reverse(section, c)

  section: '[' ... ']' EOL kv * {
    node $2
  }
    <-  write('[')
        write(n.name)

  kv: key EQ value {
    node $1 {
      value $2
    }
  }
    <- write(n.name)
       write(EQ.default)
       write(n.value)

  value: ... EOL ( INDENT ... EOL )+
    -> 
    <- nil
