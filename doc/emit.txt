Emitting the tree as a config file
----------------------------------

Each grammar has a dual grammar. The dual grammar consists of the same
rules as the primary grammar, but the rules are modified to account for
actions and to remove terminals that are not reflected in the tree.

To compute the dual of a rule:
  (1) start with the original rule. 
  (2) For each action of the form 'LOC { PATH = VALUE }' insert 
      '[ PATH = VALUE : ' at the beginning of the scope of the action and
      ']' at the end.
  (3) Remove every terminal from the rule
  (4) Remove nonterminals that produce nothing

What remains are rules made up of the nonterminals of the original grammar,
actions inserted into the rules, and metasyhntactic constructs like ( ... )
* etc.

For example, for the grammar (inistyle/yum)

  file: ( comment | section ) * {
    @0 { 'yum' }
  }

  comment: OPT_WS ( /#.*/ | 'REM' | 'rem' )? EOL

  section: '[' ... ']' EOL ( comment | kv ) * {
    @1 { $2 }
  }

  kv: ... EQ ... EOL {
    @$3 { $1 = $3 }
  }

the dual is

  file: ( [ 'yum' : section ] ) *
  section: ( [ $2 : kv ] ) *
  kv: [ $1 = $3: ]

lens/functional style is:

  file = enter['yum'] (comment | section ) * exit
  section = '[' enter[...] ']' EOL (comment | kv )* exit
  kv = enter[...] EQ assign[...] EOL exit

and for /etc/hosts
  file: ( comment | record ) *
  record: ... SEP ... ( SEP ... ) * EOR

the dual is

  file: [ 'hosts' ( record ) * ]
  record: [ $seq [ 'ipaddr' = $1 ] 
                 [ 'canonical' = $3: ] 
                 [ 'aliases' ( $seq = $5 ) * ] ]

lens/functional style is:
  file   = enter['hosts'] ( record ) * exit
  record = enter[$index] enter['ipaddr'] assign[...] exit SEP
             enter['canonical'] assign[...] exit
             enter['aliases'] ( SEP enter[$seq] assign[...] exit ) * exit EOR

To 'parse' the tree against the dual grammar and to output the config file,
do the following:

- mark all nodes in the tree as unprocessed
- treat the (dual) grammar constructs thusly:
  - embed quantifiers +, *, ? in the corresponding loop with the lookahead
    condition being 'have_unprocessed_nodes && made_progress'
  - for sequences, process each item
  - for alternatives, try each item until one succeeds
  - for [ PATH = VALUE: A ]
      - bind values in current rule
        each variable path component must correspond to an unprocessed node
        and mark each used tree node as processed
        o value is processed if it has been processed once
        o path segment is processed if it has been processed once
        o node has been processed if all values and path segements in its
          subtree have been processed


hosts/                                   P
  2/                                     PN
    ipaddr = 127.0.0.1                   PVN
    canonical = localhost.localdomain    PVN
    aliases/                             PN
      0 = localhost                      PVN
      1 = galia.watzmann.net             PVN
      2 = galia                          PVN
  5/
    ipaddr = 172.31.122.14
    canonical = orange.watzmann.net
    aliases/
      0 = orange

yum/                                                 P
  fedora/                                            PN
    name = 'Fedora $releasever - $basearch'          PVN
    enabled = '1'                                    PVN
    gpgcheck = '1'                                   PVN
  fedora-debuginfo/                                  P
    name = 'Fedora $releasever - $basearch - Debug'  PVN
    mirrorlist = 'http://mirrors.fedoraproject.org/' 
    enabled = '0'
  fedora-source/
    name = 'Fedora $releasever - Source'
    enabled = '0'
    gpgcheck = '1'


Lenses
------

Lenses all go from text files to trees. The text files are specified by a
grammar whose language is C. So lenses are C <=> T

Well-behaved
  lens l
    (l.put (l.get [c p]) [c p]) = [c p]
    (l.get (l.put [a q] [c p])) = [a q]

Tree concatenation:
  t = t1.t2  tree whose root has first-level children from t1 and t2 as
             children

  expand to [tree path]: [t1 p1].[t2 p2] = [t1.t2 p1] iff p1 = p2
                         undef otherwise

Primitive lenses:
  drop       -- drop something and don't put it into t
  enter      -- append to the current path
  exit       -- remove last component from current path
  assign     -- assign to the current path

Combinators:
  l1 . l2        -- sequence
  l1 | l2        -- alternative
  l1*, l1+, l1?  -- Kleene star, l1 . l1*, e | l1

Details:

  drop E  [[E]] <=> {}
    get [c p]         = [{} p]
    put [t q] [c p]   = [c q]
    create a    = e
  
    (same as const E e e)

    well-behaved:
      (put (get [c p]) [c p]) = (put [{} p] [c p]) = c p
      (get (put [t q] [c p])) = (get [c q]) = [{} q] iff t = {}

  enter E [[E]] <=> T
    get [c p]       = [{p/c = {}} p/c]
    put [t q] [c p] = 
    create a     =

    well-beaved:
      (put (get [c p]) [c p]) = (put [{ p/c = {} } p/c] [c p]) = [c p]
      (get (put [t q] [c p])) = (get ) = [t q]

  exit
    get [c p]         = [{} p']   with p = p'/x
    put [t q] [c p]   = 
    create =

    well-behaved:
      (put (get [c p'/x]) [c p'/x]) = (put [{} p'] [c p'/x]) = 
      (get (put [t q] [c p]) [c p])

  assign E
    get [c p]       = [{ p:c = {} } p]
    put [t q] [c p] =  

  la . lb
    let c = c1 . c2, t = t1 . t2
    get [c p]       = (la.get [c1 p]) . (lb.get [c2 p]) with c = c1 . c2
    put [t q] [c p] = (la.put [t1 q] [c1 p]) . (lb.put [t2 q] [c2 p]) 

    well-behaved
      ((la.lb).put ((la.lb).get [c1.c2 p]) [c1.c2 p])
        = ((la.lb).put (la.get [c1 p]) . (lb.get [c2 p]) [c1.c2 p])
        = (la.put (la.get [c1 p]) [c1 p]) . (lb.put (lb.get [c2 p]) [c2 p])
        = [c1 p] . [c2 p]
        = [c1.c2 p]

      ((la.lb).get ((la.lb).put [t q] [c p]))
        = ((la.lb).get (la.put [t1 q] [c1 p]) . (lb.put [t2 q] [c2 p]))
        = (la.get (la.put [t1 q] [c1 p])) . (lb.get (lb.put [t2 q] [c2 p]))
        =  [t1 q] . [t2 q] = [t q]

Scratch
-------

  l1.l2 from boomerang:

    (get c1.c2) = (l1.get c1).(l2.get c2)
    (put a1.a2 c1.c2) = (l1.put a1 c1) (l2.put a2 c2)

    well-behaved
      (put (get c1.c2) c1.c2) = (put (l1.get c1).(l2.get c2) c1c2)
        = (l1.put (l1.get c1) c1).(l2.put (l2.get c2) c2) = c1.c2

  (enter e1).(assign e2).get [c p]
    = ((enter e1).get [c1 p]) . ((assign e2).get [c2 p])
    = [ {p/e1 = {}} p/e1 ] . [ {p:c2 = {}} p] <- not defined
    we want the path from the first lens to propagate to the second


Lenses for simpler languages
============================

Translate (key sep value eol)* to { key:value }* where key, sep, value, eol
are regexps

   (enter(key) . del(sep) . assign(value) . del(eol) . exit)*

Def: Lens l: C <=> A well-behaved iff
  (GP) put(get(c), c) = c
  (PG) get(put(a, c)) = a

Lemma: lenses la: C1 <=> A1, lb: C2 <=> A2 well-behaved 
    => l = la x lb: C1 x C2 <=> A1 x A2 well behaved

  c = [c1 c2]  a = [a1 a2]

  (GP) l.put(l.get(c), c) = l.put([l1.get(c1) l2.get(c2)], [c1 c2])
       = [l1.put(l1.get(c1), c1) l2.put(l2.get(c2), c2)] = [c1 c2] = c
  (PG) l.get(l.put(a, c)) = l.get([l1.put(a1, c1) l2.put(a2, c2)])
       = [l1.get(l1.put(a1, c1)) l2.get(l2.put(a1, c1))] = [a1 a2] = a
   
Lenses go between S x P <=> T x P and
    get = sget x pget 
    put = sput x pput
where sget/sput: S <=> T and pget/pput: P <=> P
    S: text  T: trees P: paths in tree

Concatenation in T x P
  [t1 p1] . [t2 p2] = [t1.t2 p2]

Paths:
    p/w path with w appended, (p/w)^ = p   (strip last component)
    
    enter re: 
      get:  [s p] = [{} p/s]
      put:  [t q] [s p] = [

    del re: cdel x id

    assign re:
      get: [s p] = [{p:s} p]

    exit:   {e} x P <=> {} x P
      get: [e p] = [{} p^]
      put: [{} q] [e p] = [e p]

      (GP) put(get([e p]), [e p]) = put([{} p'], [e p]) = [e p]
      (PG) get(put([t q], [s p])) = get([s p]) = [{} p^] = [t q]
             iff t = {} and q = p^

    la . lb:   s = s1.s2
      get: [s p] = [ la.sget(s1) . lb.sget(s2) lb.pget(la.pget(p)) ]
                 = [ la.get([s1 p]) ] . [ lb.get([s2 la.pget(p)]) ]

    la*:       s = s1.s2...sn
      get: [s p] = [ la.sget(s1). ... .la.sget(sn) la.pget^n(p) ]


Examples of what is desired:

(E1)

  for k =~ key, v =~ value
  enter(key) . assign(value) . exit
    get: [k.v /] -> [{k:v} /]
    put: { key':value' = {} } key.value -> key'.value'

    get: (enter(key) . assign(value) . exit) [ k.v / ] 
       =  [ enter(key)([k /]) ]
        . (assign(value).exit) [v /k]
       =  [{} /k]
        . [assign(value) [v /k]]
        . [exit [e /k]]
      = [{} /k] . [{k:v} /k] . [{} /]
      = [{k:v} /k] . [{} /] = [{k:v} /]
 
    put: (enter(key) . assign(value) . exit) [{k:v} /] [k.v /]
       = enter(key) [{k:v} /] [k.v /]
       . (assign(value) . exit) [{k:v} /k] [k.v /]

(E2)
      (enter('foo') . '=' . store(...) . exit)
    | (enter('bar') . ':' . enter('val1') . store(...) . ' ' . exit
                          . enter('val2') . store(...) . exit)

Sources of ambiguity during put:
--------------------------------

  Have pos in text, node in tree; need to decide at each turn which of the
  three options to take:
    (1) Output text, stay at node   (inert text)
    (2) Replace text by node        (change of existing text)
    (3) Output node, stay at text   (insert of node)
    (4) Skip text, stay at node     (delete of text)

  a*    - need to align subtrees with their matches in the text
          enough to mark entries in the tree from original file ?
          since there is no op to rename the node, if a node name doesn't
          match the text, it must be new

  a1|a2|..|an
          (1) input matches ai, tree matches aj
             (1.1) ai does not perform tree op: copy match to output
             (1.2) ai performs tree op
               (1.2.1) tree matches ai: ai.put
               (1.2.2) tree does not match ai: aj.create
                       (where aj first ai operating on tree)
            (1a) text 

  a.b    - when a matches <e>
           need handle(a) disj handle(b)

Handle of a rule:
-----------------
  handle: rule -> re + { nil }

  handle( enter(re) ) = re  re must not match <e> or /
  handle( enter($seq) ) = /[0-9]+/

  handle(a|b) = handle(a) | handle(b)
  handle(a1.a2...an) = handle(ai)    where handle(aj) = nil 1 <= i < j <= n
                       nil           otherwise
  handle(a*)  = handle(a)
  
  handle = nil for everything else

UL traversal:
-------------

Traversal of both trees simultaneously with position (p, a) p in config
tree, a in AST. Start at root of AST with p = root->path

For ast node: ch(ast) list if children with non-null path

Invariants:
 (1) p == ast->path
 (2) for all ast nodes: |ch(ast)| == { x.path | x in ch(ast) } 
        (i.e. paths are distinct)

traverse(p, ast) {
  if (|ch(ast)| > 1) {
    ac = ast->children;
    for each child pc of p {
      found = 0;
      while (! found && ac) {
        if (ac->path is nil) {
          ac = ac->next
        } else if (ac->path is right_sibling(pc)) {
          // e.g. ac = /hosts/1, pc = /hosts/0
          new = create(pc, a)
          insert new between ac->prev and ac
          found = 1
        } else if (ac->path == pc) {
          traverse(pc, ac)
          ac = ac->next
          found = 1
        } else {
          // e.g. ac = /hosts/0, pc = /hosts/1
          del = ac
          ac = ac->next
          ast_delete(del)
        }
      }
      if (ac == NULL) {
        new = create(pc, a)
        append new to ast->children
      }
    }
    while (ac != NULL) {
      if (ac->path != NULL)
        ast_delete(ac)
    }
  } else {
    ac = sole element of ch(ast)
    traverse(ac.path, ac)
  }
  if (ast is store for p) {
    // ast must be leaf
    ast->token = aug_get(p)
  }
}


For this to work, need enter as early as possible in the tree:
  pullup of enters:
    - never out of a rule
    - only up to a parent
    - for field refs, never before a field def
  simpler:
    only promote from alternative to quantifier
    what about unquantified alternatives ? no problem since
      they have only one child in the AST


traverse(p, ast) {
  assert(p == ast->path);
  if (leaf(ast)) {
    ast->token = aug_get(p);
  } else {
    pc = firstchild(p);
    ac = firstchild(ast); // skips children with NULL path
    if (pc == ac.path) {
      traverse(pc, ac);
    } else if (pc < ac.path) {
      
    } else {
      
    }
  }
}
