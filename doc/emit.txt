Emitting the tree as a config file
----------------------------------

Lenses
------

Lens notation for hosts (with appropriate regexps):

  def file = [ label 'hosts' . ( comment | record ) * ]
  def comment = POUND_TO_EOL
  def record  = [ seq .
                  [ label 'ipaddr' . store ... ]
                  [ label 'canonical' . SEP . store ... ]
                  [ label 'aliases' . ( SEP2 . assign $seq ... ) * ] 
                  EOR
                ]

Lens notation for yum:

  def file = [ label 'yum' . ( comment | section ) * ]
  def comment = OPT_WS ( /#.*/ | 'REM' | 'rem' )? EOL
  def section = [ '[' . key ... . ']' . EOL . (comment | kv) * ]
  def kv = [ key ... . EQ . store ... . EOL ]

Lens notation for pam:

  def COMMENT = /(#.*?|[ \t]*)\n/
  def file = [ label 'pam' . [ basename . ( comment | record ) * ] ]
  def comment = match COMMENT
  def CONTROL = /(\[[^\]]*\]|[^ \t]+)/
  def record = [ seq . [ label 'type' . store ... . SEP ]
                       [ label 'control' . store CONTROL . SEP ]
                       [ label 'module' . store ... ]
                       ( SEP [ label 'opts' . store ... ] )? EOL

Lenses all go from text files to trees. The text files are specified by a
grammar whose language is C. So lenses are C <=> T

Well-behaved
  lens l
    (l.put (l.get c) c) = c
    (l.get (l.put a c)) = a

Tree concatenation:
  t = t1.t2  tree whose root has first-level children from t1 and t2 as
             children

Primitive lenses:
  drop RE       -- drop something and don't put it into t
  store RE      -- create leaf
  seq
  label
  basename

All lenses have functions
  l.get      C -> T
  l.put      
  l.create   T -> C
  l.path     C -> K
  l.parse    

Combinators:
  l1 . l2        -- sequence
  l1 | l2        -- alternative
  l1*, l1+, l1?  -- Kleene star, l1 . l1*, e | l1
  [ l ]          -- subtree

Details:

  drop E  [[E]] <=> {}
    get c         = {}
    put {} c      = c
  
    (same as const E e e)

    well-behaved:
      (put (get c) c) = (put {} c) = c
      (get (put t c)) = (get c) = {} iff t = {}

  [ l ] (l well-behaved)
    get c    = { c1 = l.get(c2) } where c = c1 . c2 ua sep
    put t c  = t1 . l.put(t2 c2)  where t = { c1 = t2 }

    well-behaved:
      (put (get c) c) = (put { c1 = l.get(c2) } c) 
        = c1 . (l.put (l.get c2) c2) = c1 . c2 = c
      (get (put t c)) = (get c1 . (l.put t2 c2))
                      = { c1 = (l.get (l.put t2 c2)) }
                      = { c1 = t2 } = t

  store E d
    get c           = {c}
    put t c         = f  iff t == {f}
                      d  iff t == {} (is this an empty tree or a leaf with NULL?)
                     undef otherwise
    well-behaved:  
    put (get c) c = put {c} c = c
    get (put a c) = get f = {f} = a

  la . lb
    let c = c1 . c2, t = t1 . t2
    get [c p]       = (la.get [c1 p]) . (lb.get [c2 p]) with c = c1 . c2
    put [t q] [c p] = (la.put [t1 q] [c1 p]) . (lb.put [t2 q] [c2 p]) 

    well-behaved
      ((la.lb).put ((la.lb).get [c1.c2 p]) [c1.c2 p])
        = ((la.lb).put (la.get [c1 p]) . (lb.get [c2 p]) [c1.c2 p])
        = (la.put (la.get [c1 p]) [c1 p]) . (lb.put (lb.get [c2 p]) [c2 p])
        = [c1 p] . [c2 p]
        = [c1.c2 p]

      ((la.lb).get ((la.lb).put [t q] [c p]))
        = ((la.lb).get (la.put [t1 q] [c1 p]) . (lb.put [t2 q] [c2 p]))
        = (la.get (la.put [t1 q] [c1 p])) . (lb.get (lb.put [t2 q] [c2 p]))
        =  [t1 q] . [t2 q] = [t q]

Scratch
-------

  l1.l2 from boomerang:

    (get c1.c2) = (l1.get c1).(l2.get c2)
    (put a1.a2 c1.c2) = (l1.put a1 c1) (l2.put a2 c2)

    well-behaved
      (put (get c1.c2) c1.c2) = (put (l1.get c1).(l2.get c2) c1c2)
        = (l1.put (l1.get c1) c1).(l2.put (l2.get c2) c2) = c1.c2

  (enter e1).(assign e2).get [c p]
    = ((enter e1).get [c1 p]) . ((assign e2).get [c2 p])
    = [ {p/e1 = {}} p/e1 ] . [ {p:c2 = {}} p] <- not defined
    we want the path from the first lens to propagate to the second


Lenses for simpler languages
============================

Translate (key sep value eol)* to { key:value }* where key, sep, value, eol
are regexps

   (enter(key) . del(sep) . assign(value) . del(eol) . exit)*

Def: Lens l: C <=> A well-behaved iff
  (GP) put(get(c), c) = c
  (PG) get(put(a, c)) = a

Lemma: lenses la: C1 <=> A1, lb: C2 <=> A2 well-behaved 
    => l = la x lb: C1 x C2 <=> A1 x A2 well behaved

  c = [c1 c2]  a = [a1 a2]

  (GP) l.put(l.get(c), c) = l.put([l1.get(c1) l2.get(c2)], [c1 c2])
       = [l1.put(l1.get(c1), c1) l2.put(l2.get(c2), c2)] = [c1 c2] = c
  (PG) l.get(l.put(a, c)) = l.get([l1.put(a1, c1) l2.put(a2, c2)])
       = [l1.get(l1.put(a1, c1)) l2.get(l2.put(a1, c1))] = [a1 a2] = a
   
Lenses go between S x P <=> T x P and
    get = sget x pget 
    put = sput x pput
where sget/sput: S <=> T and pget/pput: P <=> P
    S: text  T: trees P: paths in tree

Concatenation in T x P
  [t1 p1] . [t2 p2] = [t1.t2 p2]

Paths:
    p/w path with w appended, (p/w)^ = p   (strip last component)
    
    enter re: 
      get:  [s p] = [{} p/s]
      put:  [t q] [s p] = [

    del re: cdel x id

    assign re:
      get: [s p] = [{p:s} p]

    exit:   {e} x P <=> {} x P
      get: [e p] = [{} p^]
      put: [{} q] [e p] = [e p]

      (GP) put(get([e p]), [e p]) = put([{} p'], [e p]) = [e p]
      (PG) get(put([t q], [s p])) = get([s p]) = [{} p^] = [t q]
             iff t = {} and q = p^

    la . lb:   s = s1.s2
      get: [s p] = [ la.sget(s1) . lb.sget(s2) lb.pget(la.pget(p)) ]
                 = [ la.get([s1 p]) ] . [ lb.get([s2 la.pget(p)]) ]

    la*:       s = s1.s2...sn
      get: [s p] = [ la.sget(s1). ... .la.sget(sn) la.pget^n(p) ]


Examples of what is desired:

(E1)

  for k =~ key, v =~ value
  enter(key) . assign(value) . exit
    get: [k.v /] -> [{k:v} /]
    put: { key':value' = {} } key.value -> key'.value'

    get: (enter(key) . assign(value) . exit) [ k.v / ] 
       =  [ enter(key)([k /]) ]
        . (assign(value).exit) [v /k]
       =  [{} /k]
        . [assign(value) [v /k]]
        . [exit [e /k]]
      = [{} /k] . [{k:v} /k] . [{} /]
      = [{k:v} /k] . [{} /] = [{k:v} /]
 
    put: (enter(key) . assign(value) . exit) [{k:v} /] [k.v /]
       = enter(key) [{k:v} /] [k.v /]
       . (assign(value) . exit) [{k:v} /k] [k.v /]

(E2)
      (enter('foo') . '=' . store(...) . exit)
    | (enter('bar') . ':' . enter('val1') . store(...) . ' ' . exit
                          . enter('val2') . store(...) . exit)

Sources of ambiguity during put:
--------------------------------

  Have pos in text, node in tree; need to decide at each turn which of the
  three options to take:
    (1) Output text, stay at node   (inert text)
    (2) Replace text by node        (change of existing text)
    (3) Output node, stay at text   (insert of node)
    (4) Skip text, stay at node     (delete of text)

  a*    - need to align subtrees with their matches in the text
          enough to mark entries in the tree from original file ?
          since there is no op to rename the node, if a node name doesn't
          match the text, it must be new

  a1|a2|..|an
          (1) input matches ai, tree matches aj
             (1.1) ai does not perform tree op: copy match to output
             (1.2) ai performs tree op
               (1.2.1) tree matches ai: ai.put
               (1.2.2) tree does not match ai: aj.create
                       (where aj first ai operating on tree)
            (1a) text 

  a.b    - when a matches <e>
           need handle(a) disj handle(b)

Handle of a rule:
-----------------
  handle: rule -> re + { nil }

  handle( enter(re) ) = re  re must not match <e> or /
  handle( enter($seq) ) = /[0-9]+/

  handle(a|b) = handle(a) | handle(b)
  handle(a1.a2...an) = handle(ai)    where handle(aj) = nil 1 <= i < j <= n
                       nil           otherwise
  handle(a*)  = handle(a)
  
  handle = nil for everything else

UL traversal:
-------------

Traversal of both trees simultaneously with position (p, a) p in config
tree, a in AST. Start at root of AST with p = root->path

For ast node: ch(ast) list if children with non-null path

Invariants:
 (1) p == ast->path
 (2) for all ast nodes: |ch(ast)| == { x.path | x in ch(ast) } 
        (i.e. paths are distinct)

traverse(p, ast) {
  if (|ch(ast)| > 1) {
    ac = ast->children;
    for each child pc of p {
      found = 0;
      while (! found && ac) {
        if (ac->path is nil) {
          ac = ac->next
        } else if (ac->path is right_sibling(pc)) {
          // e.g. ac = /hosts/1, pc = /hosts/0
          new = create(pc, a)
          insert new between ac->prev and ac
          found = 1
        } else if (ac->path == pc) {
          traverse(pc, ac)
          ac = ac->next
          found = 1
        } else {
          // e.g. ac = /hosts/0, pc = /hosts/1
          del = ac
          ac = ac->next
          ast_delete(del)
        }
      }
      if (ac == NULL) {
        new = create(pc, a)
        append new to ast->children
      }
    }
    while (ac != NULL) {
      if (ac->path != NULL)
        ast_delete(ac)
    }
  } else {
    ac = sole element of ch(ast)
    traverse(ac.path, ac)
  }
  if (ast is store for p) {
    // ast must be leaf
    ast->token = aug_get(p)
  }
}


For this to work, need enter as early as possible in the tree:
  pullup of enters:
    - never out of a rule
    - only up to a parent
    - for field refs, never before a field def
  simpler:
    only promote from alternative to quantifier
    what about unquantified alternatives ? no problem since
      they have only one child in the AST


traverse(p, ast) {
  assert(p == ast->path);
  if (leaf(ast)) {
    ast->token = aug_get(p);
  } else {
    pc = firstchild(p);
    ac = firstchild(ast); // skips children with NULL path
    if (pc == ac.path) {
      traverse(pc, ac);
    } else if (pc < ac.path) {
      
    } else {
      
    }
  }
}
